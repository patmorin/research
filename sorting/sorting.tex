\documentclass{patmorin}
\usepackage{pat,amsopn}

\DeclareMathOperator{\height}{height}


\title{An Improved Lower Bound for Comparison-Based Sorting}
\author{\ }


\begin{document}
\maketitle

\begin{abstract}
We show that any deterministic comparison-based sorting algorithm performs
at least $\log(n!) + n/9 - O(\log n)$ comparisons for some input.
\end{abstract}

\section{Introduction}

In this paper, we prove the following theorem:

\begin{thm}\thmlabel{lower-bound}
  For any deterministic comparison-based sorting algorithm, $\mathcal{A}$,
  there exists a permutation of $\{1,\ldots,n\}$ on which $\mathcal{A}$
  performs at least $\log(n!)+n/9-O(\log n)$ comparisons.
\end{thm}

\section{Preliminaries}

A \emph{comparison tree}, $T$, for sorting $n$ elements is a binary tree.
Each internal node, $u$, of $T$ is labelled with an ordered pair of
indices $(i_u,j_u)$.  Each leaf, $\ell$, of $T$ is labelled with a
permutation, $\pi_\ell$, of $\{1,\ldots,n\}$.

Every sequence, $a=a_1,\ldots,a_n$, of numbers defines a root-to-leaf
path, $T(a)$, in a comparison tree, $T$, as follows:  The first node
in $T(a)$ is the root.  When situated at an internal node $u$, the path
$T(a)$ continues to $u$'s left child if $i_u < j_u$ and continues to
$u$'s right child otherwise.

We say that the comparison tree $T$ \emph{sorts a set of sequences}, $A$,
if, for every sequence $a_1,\ldots,a_n\in A$, $T(a_1,\ldots,a_n)$ ends at
a leaf, $\ell$, that is labelled with a permutation $\pi_\ell$ such that:
\[
    a_{\pi_\ell(1)} \le a_{\pi_\ell(2)} 
        \le \cdots \le a_{\pi_\ell(n)} \enspace .
\]
We say, simply, that $T$ \emph{sorts} if it sorts the set $\R^n$.  It is
not hard to verify that, for $T$ to sort, it is sufficient for $T$ to sort
the set, $\Pi_n$, of all permutations of the integers $\{1,\ldots,n\}$. We call the elements of $\Pi_n$ \emph{inputs}.

Note that, for any node, $u$, in a comparison tree, there exists a maximal
set of inputs, $A(u)$, such that $T(a)$ contains $u$ for all $a\in A$.
That is, every permutation in $A(u)$ leads to $u$.  In this paper, we
are interested in comparison trees of minimum height. We can therefore
assume that our comparison trees have the following properties:

\begin{prp}[No unreachable nodes]\prplabel{can-reach}
  For any node $u$ in $T$, $A(u)\neq\emptyset$.
\end{prp}

\begin{prp}[No useless comparisons]
  Each internal node $u$ of $T$ has at least 2 children.
\end{prp}

\begin{prp}[Subtree optimality]
  For any node, $u$ of $T$, the subtree rooted at $u$ is a comparison tree
  of minimum height that sorts $A(u)$. 
\end{prp}

It is well known that, for any deterministic comparison-based sorting
algorithm, $\mathcal{A}$, the actions of $\mathcal{A}$ can be modelled by
a comparison tree, $T_\mathcal{A}$.  Thus, to prove \thmref{lower-bound},
it suffices to prove the following equivalent lemma:

\begin{lem}\lemlabel{lower-bound}
  Every comparison tree that sorts $\Pi_n$ has height at least
  $\log(n!)+n/9-O(\log n)$.
\end{lem}

\section{The Lower Bound}

The sketch of our lower-bound argument is as follows:  We first show
that, for any comparison tree, $T$, that sorts, there exists an input
$a=a_1,\ldots,a_n$ such that $T(a)$ has length $\log(n!)-O(\log n)$ and
that there are $n/9-O(\log n)$ comparisons performed along the path $T(a)$
that are \emph{lucky} (in a formal sense, defined below).  We then use
the existence of these efficient comparisons to derive another comparison
tree $T'$ and another permutation $a'$ with the following two properties,
which establish \lemref{lower-bound}:
\begin{enumerate}
  \item The height of $T'$ does not exceed the height of $T$.
  \item $T'(a')$ has length at least $\log(n!)+n/9-O(\log n)$.
\end{enumerate}
In particular, these two properties imply that
\[
   \height(T) \ge \height(T') \ge \log(n!)+n/9-O(\log n) \enspace .
\]
(The first inequality is implied by the first property and the second
inequality is implied by the second property.)  We emphasize that the
tree $T'$ does not necessarily sort any sequence other than $a'$.

\subsection{Lucky and Unlucky Triples}

Our proof relies on grouping elements of the input $a$ into $n/3$ triples.
For the remainder of the paper we will assume, only for simplicity,
that $n\equiv 0\pmod{3}$. 

We need a notation to refer to the position of the item $i$ in an input
$a=a_1,\ldots,a_n$.  For this purpose, we define the \emph{inverse}
$\bar{a}=\bar{a}_1,\ldots,\bar{a}_n$ so that $\bar{a}_i$ is the unique
index $j$ such that $a_j=i$.

We group the indices of $a$ into $n/3$ triples
(sets of size 3), $t_1,\ldots,t_{n/3}$, where
$t_i=\{\bar{a}_{3i-2},\bar{a}_{3i-1},\bar{a}_{3i}\}$.  That is, each
$t_i$ contains the indices of 3 consecutive values in $\{1,\ldots,n\}$.
Triples are useful, because $T$ can gain no information about the relative
ordering of the elements in a triple except by comparing two elements,
both of which are in the triple.

If $T$ sorts then, for any input $a$ and any triple $t_i$ of $a$,
$T(a)$ must contain at least 2 nodes $u$ such that $i_u$ and $j_u$
are both in $t_i$.  In some cases, $T(a)$, contains three such nodes.
In the former case, we say that $T$ \emph{got lucky} for the triple $t_i$
and we say that $T$ was \emph{unlucky} (for $t_i$) otherwise.  In the
case where $T$ is lucky for $t_i$, we call the second node on $T(a)$
that compares two indices in $t_i$ a \emph{lucky node}.

\begin{lem}\lemlabel{triples}
  Let $a_1,\ldots,a_n$ be a random permutation of $\{1,\ldots,n\}$.
  Then the expected number of lucky nodes in $T(a)$ is $n/9$ and the
  expected number of unlucky nodes in $T(a)$ is $2n/9$.
\end{lem}

\begin{proof}
For a triple $t_i=\{i_1,i_2,i_3\}$, let $x=a_{i_1}$, $y=a_{i_2}$, and
$z=a_{i_3}$.  Assume, without loss of generality that the first comparison
within $t_i$ determines that $x<y$ and that the second comparison is
between $y$ and $z$ (other cases are symmetric).  Conditioned only on
the assumption, $x<y$, each of the tree possibilities for the location
of $z$ is equally likely.  In particular, the relative ordering
\[
   x < y < z
\]
occurs with probability $1/3$.  This is the only case in which the total ordering of $x$, $y$, and $z$ can be determined with only two comparisons.  In the other cases (with probability $2/3$), an additional comparison is required to distinguish between 
\[
   x < z < y
\]
and 
\[
   z < x < y \enspace .
\]
Thus with probability $1/3$ $T$ is lucky for $t_i$ and with probability
$2/3$ $T$ is unlucky.  The lemma then follows from linearity of
expectation.
\end{proof}

\begin{lem}\lemlabel{permutation}
  For any decision tree $T$, the exists an input $a=a_1,\ldots,a_n$
  such that the root-to-leaf path defined by $a$ has length at least
  $\log(n!)-4$ and the number of triples on which $T$ wins is at least
  $n/12$.
\end{lem}

\begin{proof}
Let $a$ be a random input.  Then, with probability at least $15/16$, the
length of the path defined by $a$ is at least $\log(n!)-4$.  (Any binary
tree contains at most $k/16$ leaves of depth at most $\log(k)-4$.)

On the other hand, the probability that $T$ wins on fewer than $n/12$
triples is equal to the probability that $T$ loses on more than $3n/12$
triples.  Letting $X$ denote the number of triples on which $T$ loses
we have, By Markov's Inequality and \lemref{triples},
\[
   \Pr\{X\ge (3/4)(n/3)\} = \Pr\{X \ge (9/8)\E[X]\} \le 8/9 \enspace . 
\]
Therefore, with probability at least $15/16$ the path defined by $a$
has length at least $\log(n!)-4$ and with probability at least $1/9$, $T$
wins on at least $n/12$ triples of $a$.  Since $15/16+1/9 > 1$ we conclude
that there exists some $a$ that satisfy the conditions of the lemma. (In
fact, a constant fraction of all permutations satisfy the lemma.)
\end{proof}

\subsection{Finding a Long Path in $T$}

Next, we show how the permutation, $a$, guaranteed by
\lemref{permutation}, can be used to find a root-to-leaf path of length
$\log(n!)+\Omega(n)$ in any comparison tree.  The construction works
by starting with the permutation $a$ and modifying the relative order
of pairs of elements within winning triples so that they become losing
triples.

For this strategy to work, we also modify the decision tree, $T$, in
ways that do not increase the length of the original search path root
to leaf path.  We do this with two kinds of operations.  The first such
operation is a \emph{lifting}.  The second is a \emph{switcheroo}.

\subsection{Lifting}

Let $a$ be an input on which a search tree loses on the triple $T_i$.
Let $u$ be the node at which this triple loses and, suppose that the
search path for $a$ proceeds to $u$'s left child.  Let $A\subset A(u)$
be subset of $A(u)$ that respects the triple structure of $a$ and
 that do not modify the triple $T_i$.  Then, every root-to-leaf path
 defined by elements of $A$ contains $u$ and, furthermore, contains a
 node in the subtree of $u$ that contains that compares the third pair
 in $T_i$.
\begin{proof}

\end{proof}

\section{Upper Bounds}

Merge sort does $n\log_2n - n +O(1)$ comparisons, in the worst case,
when $n$ is a power of 2.  How about the average case?  To answer this
we need to know the answer to the following question: Given a random
sequence containing $2^i$ red items and $2^i$ blue items, what the
expected length of the initial monochromatic sequence?

Insertion sort does
\[
   \sum_{i=2}^{n}\lceil\log_2 i\rceil \le \log(n!) + n
\]
in the worst case.  How much better does it do in the average case?
(I think it's $\log(n!)+3n/4$.)


\end{document}
