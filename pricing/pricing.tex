\documentclass[lotsofwhite]{patmorin}
\usepackage{amsmath,graphicx}

\input{pat}

\title{\MakeUppercase{Algorithms for Price/Quality Tradeoffs}}
\author{Joachim Gudmundsson%
	\and Pat Morin%
	\and Michiel Smid}

\newcommand{\cost}{\operatorname{cost}}
\newcommand{\ppu}{\operatorname{ppu}}
\newcommand{\val}{\operatorname{profit}}

\begin{document}
\maketitle
\begin{abstract}
The abstract should go here.
\end{abstract}

\newpage

\tableofcontents

\newpage 

\section{Introduction}

[Maybe we should cite a book about Choice Modelling]

This paper considers a marketing problem in which a product
$P=(p,q_1,\ldots,q_d)$ is defined by a real-valued \emph{price}, $p$,
and a number of real-valued orthogonal \emph{qualities},
$q_1,\ldots,q_d$.  The \emph{market} for a product is a collection of
customers $C=\{C_1,\ldots,C_n\}$, where
$C_i=(p_i,q_{i,1},\ldots,q_{i,d})$.  A customer will purchase the
least expensive product that meets all their minimum quality
requirements and whose price is below their maximum price range.  That
is, the customer $C_i$ will \emph{consider} the product
$P=(p,q_1,\ldots,q_d)$ if $p \le p_i$ and $q_j \ge q_{i,j}$ for all
$j\in\{1,\ldots,d\}$.  The customer $C_i$ will \emph{purchase} the
product if it has minimum price among all available products that
$C_i$ considers.

We consider markets that are \emph{saturated}.  That is, for every
customer there is an existing product that satisfies their
requirements. From the point of view of a manufacturer introducing one
or more new products, this means that all customers are \emph{Pareto
optimal}, i.e., there are no two customers $C_i$ and $C_j$ such that
$q_{i,k} > q_{j,k}$ for all $k\in\{1,\ldots,d\}$ and $p_i < p_j$.
This is because, in a saturated market $C_j$ and $C_i$ will purchase
the same product, namely the lowest-priced product that satisfies
$C_i$'s requirements.  In such a market, there is no need to
explicitly consider existing products since these can be encoded into
the customers themselves.

As an example of such a market, consider a market for computers in
which an example customer $C_i$ may be looking for a computer with a
minimum of 8 GB of RAM, a CPU benchmark score of at least 3000, a GPU
benchmark score of at least 2000, and be willing to pay at most
\$1500.  In addition, there is already a computer on the market which
meets these requirements and retails for \$1200.  Thus, this customer
would be described by the vector $(1200,8,3000,2000)$.  If a
manufacturer introduces a new product $(1199,8,3500,2000)$ then this
customer would select this new product over their existing choice.

By appropriately parameterizing the axes, we can assume that the cost, 
$\cost(P)$, of manufacturing $P$ is equal to the sum of its qualities
\[
   \cost(P) = \sum_{i=1}^d q_i \enspace .
\]
The \emph{profit per unit sold} of $P$ is therefore
\[
   \ppu(P) = p-\cost(P) \enspace .
\]
In this paper we consider algorithms that a manufacturer can use when
choosing new products to introduce into an existing saturated market.
The goal of a manufacturer is to introduce 1 or more new products into
the market in order to maximize their profit.  More precisely, given
a positive integer $k$ and a emph{market} of customers
$M=\{C_1,\ldots,C_n\}$, each have $d$ qualities,
the $\textsc{ProductDesign}(d,k)$ problem is to find $k$ products $P_1,\ldots,P_k$ such that 
\[
  \val(P_1,\ldots,P_k) = \sum_{j=1}^k \ppu(P_j)
    \times 
      \left|
       \left\{
         i:\mbox{$C_i$ purchases $P_j$ when $P_1,\ldots,P_k$ are available}
       \right\}
      \right|
\]
is maximized.  

\section{The Single Product Case}

In this section we consider cases of $\textsc{ProductDesign}(d,k)$
where number, $k$, of new products to introduce is 1.  We begin by
giving an $O(n\log n)$ algorithm and $\Omega(n\log n)$ lower bound for
the case $d=1$.

\subsection{An $O(n\log n)$ algorithm for $d=1$}

In this section, we consider the simplest case, when the manufacturer
wishes to introduce one new product in which the quality of a product
has only one dimension.  Examples of such markets include, for
example, suppliers to the construction industry in which items (steel
I-beams, finished lumber, logs) must have a certain minimum length to
be used for a particular application.  An overly long piece can be cut
down to size, but gluing two short pieces together is not an option.

Throughout this section, since $d=1$ and $k=1$, we will use the
shorthand $q_i$ for $q_{i,1}$ and $P=(p,q)$ for $P_1$.  Thus, we have
a set of customers $M=\{(p_1,q_1),\ldots,(p_{n},q_n)\}$ and we are
searching for a point $P=(p^*,q^*)$ that maximizes $\val(p^*,q^*)$.

Our algorithm is an implementation of the \emph{plane-sweep} paradigm
\cite{bsXX}.  The correctness of the algorithm relies on two lemmas
about the structure of the solution space.  The first lemma is quite
easy:

\begin{lem}\lemlabel{discrete}
  The value $(p^*,q^*)$ that maximizes $\val(p^*,q^*)$ is obtained when
  $p^* = p_i$ and $q^*=q_j$ for some $i,j\in\{1,\ldots,n\}$.
\end{lem}

\begin{proof}
  First, observe the obvious bounds on $p^*$ and $q^*$:
  \[
     \min\{p_i:i\in\{1,\ldots,n\}\} \le p^* 
      \le \max\{p_i:i\in\{1,\ldots,n\}\} 
  \] 
  and 
  \[
     \min\{q_i:i\in\{1,\ldots,n\}\} \le q^* 
      \le \max\{q_i:i\in\{1,\ldots,n\}\} \enspace .
  \] 
  Consider the arrangement of lines obtained by drawing a
  horizontal and vertical line through each customer $(q_i,p_i)$
  for $i\in\{1,\ldots,n\}$.  Within each cell of this arrangement,
  the function $\val(p,q)$ is a linear function of $p$ and $q$ and it is
  bounded.  Therefore, within a particular cell, the function is maximized
  at a vertex.  Since each vertex is the intersection of a horizontal
  and vertical line through a pair of customers, the lemma follows.
\end{proof}

The following lemma, illustrated in \figref{lemma-monotone}, is a
little more subtle and illustrates a manufacturing preference for
lower-quality products:
\begin{figure}
  \begin{center}
    \includegraphics{lemma-monotone}
  \end{center}
  \caption{$\val(p,q) \le \val(p,q')$ implies that $\val(p',q) \le
           \val(p',q')$ for all $p' \le p$.}
  \figlabel{lemma-monotone}
\end{figure}

\begin{lem}\lemlabel{monotone}
  Let $q' \le q$ and let $p$ be such that $0 < \val(p,q) \le \val(p,q')$.
  Then, for any $p' \le p$, $\val(p',q) \le \val(p',q')$.
\end{lem}

\begin{proof}
  By definition, $\val(p,q) = a(p-q)$ and $\val(p,q') = a'(p-q')$, where
  $a$ and $a'$ are the number of customers who would consider $(p,q)$
  and $(p,q')$, respectively.  These customers are all taken from the
  set $M_\ge =\{(p_i,q_i)\in M: p_i \ge p\}$.

  Now, consider the customers in the set $M'=\{(p_i,q_i)\in M: p' \le
  p_i < p\}$.  By the assumption that customers are Pareto optimal,
  any customer $(p_i,q_i)$ in $M'$ has $q_i \le q'$, so all of these
  customers will consider either $(p',q')$ or $(p',q)$ if either one
  is offered.  Therefore,
  \[
    \begin{aligned}
      \val(p',q')
        &  =   (a'+|M'|)(p'-q') \\
        &  =   a'(p'-q') + |M'|(p'-q') \\
        & \ge  a'(p'-q') + |M'|(p'-q) 
               && \mbox{since $q > q'$} \\
        &  =   a'(p-q') + a'(p'-p) + |M'|(p'-q) \\
        & \ge  a'(p-q') + a(p'-p) + |M'|(p'-q) 
               && \mbox{since $a \ge a'$ and $(p'-p) < 0$} \\
        & \ge  a(p-q) + a(p'-p) + |M'|(p'-q) 
               && \mbox{by assumption} \\
        &  =  a(p'-q) + |M'|(p'-q) \\
        &  =  \val(p',q) \enspace , \\
    \end{aligned}
  \]
  as required.
\end{proof}

\lemref{monotone} allows us to apply the plane sweep paradigm with a sweep
by decreasing price.  It tells us that, if a product $(p,q')$ gives better
profit than the higher-quality product $(p,q)$ at the current price $p$,
then it will always give a better profit for the remainder of the sweep.
In particular, there will never be a reason to consider a product with
quality $q$ for the remainder of the algorithm's execution.

Let the customers be labelled $(p_1,q_1),\ldots,(p_n,q_n)$ in decreasing
order of $p_i$, so that $p_{i+1} < p_i$ for all $i\in\{1,\ldots,n-1\}$.
At any point in the sweep algorithm, there is a current price $p$,
which starts at $p=\infty$ and takes on the values $p_1,\ldots,p_n$,
successively, during the execution of the algorithm.  At all times, the
algorithm maintains a list $L$ of qualities $q_1^* > q_2^* > \cdots >
q_m^*$ such that $\val(p,q_1^*) > \val(p,q_2^*) >\cdots>\val(p,q_m^*)$.

What remains is to show how $L$ is updated during the processing
of a sweep line event.  For this, the algorithm uses an auxiliary
structure $D$ to efficiently identify items in $L$ that need to updated.
Consider a consecutive pair of the elements $q^*_i$ and $q^*_{i+1}$
in $L$.  When $q^*_i$ and $q^*_{i+1}$ became adjacent in $L$, it was
at some price $p=p_t$ such that $\val(p_t,q^*_i)>\val(p_t,q^*_{i+1})$.
Let $a_i$ and $a_{i+1}$ be the number of customers who would consider
$(p_t,q^*_i)$ and $(p_t,q^*_{i+1})$, respectively. Then,
\[
  \val(p_t,q^*_i) = (p_t-q^*_i)a_i
\]
and
\[
  \val(p_t,q^*_{i+1}) = (p_t-q^*_{i+1})a_{i+1}
\]
Now, looking forward in time to a later step in the execution of
the algorithm, when $p=p_{t'}$, with $t'> t$, we find that
\[
  \val(p_{t'},q^*_i) = (p_{t'}-q^*_i)(a_i+t'-t)
\]
and
\[
  \val(p_{t'},q^*_{i+1}) = (p_{t'}-q^*_{i+1})(a_{i+1}+t'-t) \enspace .
\]
In particular, we interested in identifying the situation
\begin{equation}
  (p_{t'}-q^*_i)(a_i+t'-t) \le (p_{t'}-q^*_{i+1})(a_{i+1}+t'-t)  \enspace ,
    \eqlabel{halfplane}
\end{equation}
at which point $q^*_i$ should be removed from $L$.  Observe that
the values of $a_i$, $a_{i+1}$, $q^*_i$, $q^*_{i+1}$ and $t$ are all
fixed at the time $q^*_i$ and $q^*_{i+1}$ become adjacent in $L$ and
the only values that change are those of $p_{t'}$ and $t'$.  Thus,
\eqref{halfplane} defines a halfplane in the plane parameterized by
$p_{t'}$ and $t'$.

The auxiliary data structure $D$ used by the algorithm must therefore be
able to store halfplanes and handle insertions, deletions, and queries
of the form ``Given a point $(x,y)$ return all halfplanes that contain
$(x,y)$.'' There are several data structures that solve this problem, but
the most suitable for the current application is the recent dynamic convex
hull data structure of Brodal and Jakob \cite{bjXX}.  Their data structure
allows for the insertion and deletion of halfplanes in $O(\log n)$ time.
Given a query point $(x,y)$, the data structure is able to, in $O(\log
n)$ time, find a single halfplane (if one exists) that contains $(x,y)$.

The data structure $D$ is used as follows.  When the sweep line is
advanced to a new price $p_{t'}$, the value $q_{t'}$ is appended to
$L$ and the halfplane defined by $q_{t'}$ and its predecessor in $L$
is inserted into $D$.  Next, the data structure $D$ is repeatedly
queried with the point $(p_{t'},t')$.  This returns a halfplane
$h$ (if any exists) that corresponds to a pair of consecutive
elements $(q_i^*,q_{i+1}^*)$ such that $\val(p_{t'},q_i^*) \le
\val(p_{t'},q_{i+1}^*)$.  The halfplane $h$ is then deleted from $D$,
$q_{i}$ is deleted from $L$, and a new halfplane corresponding to the
(now adjacent) elements $q_{i-1}$ and $q_{i+1}$ is inserted into $D$.
This process is repeated until querying $D$ with the value $(p_{t'},t')$
returns no result.

Note that, after all the processing associated with updating the price
$p_{t'}$, the first element, $q_1$, in $L$ is the value that maximizes
$\val(q_1,p_{t'})$. Thus, the algorithm need only keep track, throughout
its execution, of the highest profit obtained from the first element of
$L$, and output this value at the end of its execution.  This completes
the description of the algorithm.

\begin{thm}
  There exists an $O(n\log n)$ time algorithm for
  \textsc{ProductDesign$(1,1)$}.
\end{thm}

\begin{proof}
  The correctness of the algorithm described above follows from 2 facts:
  \lemref{discrete} ensures that the optimal solution is of the form
  $(p_i,q^*)$ for some $i\in\{1,\ldots,n\}$, and \lemref{monotone}
  ensures that the optimal solution appears at some point as the first
  element of the list $L$.

  The running time of the algorithm can be bounded as follows: Presorting
  the customers by decreasing order of price can be done in $O(n\log n)$
  time using any $O(n\log n)$ time sorting algorithm. Each sweep line
  event involves 1 insertion into $D$ plus some number $k$ of deletions,
  and insertions, and $k+1$ queries.  Note that each deletion in $D$
  corresponds to a deletion in $L$.  Therefore, the total number of such
  deletions during the entire execution of the algorithm does not exceed
  $n$, and each such insertion/deletion pair takes $O(\log n)$ time.
  Since there are $n$ events, we conclude that the total running time
  of the algorithm is therefore $O(n\log n)$.
\end{proof}

The following theorem shows that a running time of $\Omega(n\log n)$
is inherent in this problem, even when considering approximation
algorithms.

\begin{lem}
  Let $M$ be an instance of $\textsc{ProductDesign(1,1)}$ and $(p^*,q^*)$
  be a solution that maximizes $\val(p^*,q^*)$.  In the algebraic decision
  tree model of computation, any algorithm that can find a solution
  $(p,q)$ such that $2 \val(p,q) > \val(p^*,q^*)$ has $\Omega(n\log n)$
  running time in the worst-case.
\end{lem}

\begin{proof}
  We reduce from the integer \textsc{Element-Uniqueness} problem, which
  has an $\Omega(n\log n)$ lower bound in the algebraic decision tree
  model \cite{boYY,yXX}: Given an array $A=[x_1,\ldots,x_n]$ containing
  $n$ integers, are all the elements of $A$ unique?

  We convert $A$ into a market problem in $O(n)$ time as follows (refer
  to \figref{lemma-lower-bound}).  For each $x_i$, $i\in\{1,\ldots,n\}$
  we introduce a customer $(p_i,q_i)$ with $p_i=q_i+1/2$ and $q_i=x_i$.
  If there exists a value $x$ in $A$ that occurs $2$ or more times, then
  the product $(x,x+1/2)$ gives a value $\val(x,x+1/2) \ge 1$.  On the
  other hand, if there is no such $x$, then \begin{enumerate} \item
  any product $(q,p)$ with $p-q>1/2$ can not be sold to any customers
  and \item any product $(q,p)$ with $p-q>0$ can be sold to at most $1$
  customer.  \end{enumerate} Therefore, if all the elements of $A$ are
  unique, then $\val(q^*,p^*) = 1/2$, otherwise $\val(q^*,p^*) \ge 1$.
  The result follows.
\end{proof}

\begin{figure}
  \begin{center}
    \includegraphics{lemma-lower-bound}
  \end{center}
  \caption{Reducing \textsc{Element-Uniqueness} to
           $\textsc{ProductDesign(1,1)}$.}
  \figlabel{lemma-lower-bound}
\end{figure}

\subsection{A near-linear approximation algorithm for $d=2$}

Let $r=\max\{\ppu(C_i) : i\in\{1,\ldots, n\}\}$ and observe that $r$
is the maximum profit per unit that can be achieved in this market.
Let $\ell = \lceil\log_{1/(1-\epsilon)} n\rceil$ and observe that $\ell =
O(\epsilon^{-1}\log n)$.\footnote{This can be seen by taking the limit
$\lim_{\epsilon\rightarrow 0^+} (\epsilon/\log(1/(1-\epsilon)))$ using one
application of L'H\^opital's Rule.} For each $i\in\{0,1,2,\ldots,\ell\}$,
define the plane $H_i = \{ (p,q_1,q_2) : p-q_1-q_2 = r(1-\epsilon)^i \}$.
The following lemma says that a search for an approximate solution can
be restricted to be contained in one of the planes $H_i$.

\begin{lem}\lemlabel{plane-approx}
  For any product $P^*=(p^*,q_1^*,q_2^*)$, there exists a product
  $P=(p,q_1,q_2)$ such that $P\in H_i$ for some $i\in\{0,\ldots,\ell\}$
  and $\val(P) \ge (1-\epsilon)\val(P^*)$.
\end{lem}

\begin{proof}
  There are two cases to consider.  If $\ppu(P^*) \le r/n$ then $\val(P^*)
  \le r$, in which case we set $P=C_i$ where $\ppu(C_i) = r$, so that
  $P\in H_0$ and $\val(P) = r \ge \val(P^*)\ge (1-\epsilon)\val(P^*)$,
  as required.

  Otherwise, $r/n < \ppu(P^*) \le r$.  In this case, consider
  the plane $H_i$ where $i = \lceil\log_{1/(1-\epsilon)}
  (r/\ppu(P^*))\rceil$.  Notice, that for any point $P\in H_i$, $\ppu(P)
  \ge (1-\epsilon)\ppu(P^*)$.  More specifically, the orthogonal
  projection $P=(p,q_1,q_2)$ of $P^*$ onto $H_i$ is a product with $p\le
  p^*$, $q_1\ge q_1^*$, and $q_2\ge q_2^*$.  Therefore, any customer
  who would consider $P^*$ would also consider $P$, so $\val(P) \ge
  (1-\epsilon)\val(P^*)$, as required.
\end{proof}

\lemref{plane-approx} implies that the problem of finding an
approximate solution to  $\textsc{ProductDesign}(2,1)$ can be reduced
to a sequence of problems on the planes $H_0,\ldots,H_\ell$.  In fact,
each customer $C_j$ defines a (possibly empty) equilateral triangle
$\Delta_{i,j}$ on the plane $H_i$ such that $C_j$ will consider a
product $P$ in $H_i$ if and only $P$ is in $\Delta_{i,j}$.  Thus, the
problem of solving $\textsc{ProductDesign}(2,1)$ restricted to the
plane $H_i$ is the problem of finding a point contained in the largest
number of equilateral triangles from the set $\Delta_i=\{\Delta_{i,j}:
j\in\{1,\ldots,n\}\}$.

Note that the elements in $\Delta_i$ are all equilateral triangles
with the same orientation, so they form a collection
\emph{pseudodisks} and we wish to find the deepest point in this
collection of pseudodisks.  No algorithm with running time $o(n^2)$ is
known for solving this problem exactly, but Aronov and Har-Peled have
recently given a $(1-\epsilon)$-approximation algorithm for this
problem that runs in time $O(\epsilon^{-2}n\log n)$.  By applying this
algorithm to each of $\Delta_i$ for $i\in\{1,\ldots,\ell\}$, we obtain
the following result:

\begin{thm}
  $\textsc{ProductDesign}(2,1)$ can be $(1-\epsilon)$-approximated in
  $O(\epsilon^{-3}n\log^2 n)$ time.
\end{thm}

\paragraph{Remark.}

For $d>2$, the above technique reduces the problem to finding a point
contained in the largest number of regular simplices in $d$
dimensions.  I can't find anything Aronov and Har-Peled, Kaplan and
Sharir, or Chan about this.  However, it should be possible to get a
running time of $O(\epsilon^{-3}n(\log n)^{O(d)})$.  To do this, we
would need an algorithm that compute the deepest point in a set of
(isothetic) simplices in $O(n k^O(d))$ time where $k$ is the depth.

\paragraph{Remark.} What is the complexity of finding the deepest
point in a collection of equilateral triangles.  Is it 3-sum hard?
Probably not, but worth checking into.  Aronov and Har-Peled's paper
would be a good place to look.

\section{Multiple Product Design}

\subsection{Approximations for $d=1$ with variable $k$}

\begin{thm}
There exists an $O((n\log_{1/(1-\epsilon)} n)^k)$ time algorithm that,
given an instance of $\textsc{ProductDesign}(1,k)$ finds a solution
$P_1,\ldots,P_k$ such that $\val(P_1,\ldots,P_k) \ge
(1-\epsilon)\val(P_1^*,\ldots,P_k^*)$, where $P_1^*,\ldots,P_k^*$ is
an optimal solution.
\end{thm}


\begin{thm}
There exists an $O(kn\log n)$ time algorithm that,
given an instance of $\textsc{ProductDesign}(1,k)$ finds a solution
$P_1,\ldots,P_k$ such that $\val(P_1,\ldots,P_k) \ge
H_n\val(P_1^*,\ldots,P_k^*)$, where $P_1^*,\ldots,P_k^*$ is
an optimal solution.
\end{thm}

\subsection{NP-hardness for $d=2$ with variable $k$}

\begin{thm}
  $\textsc{ProductDesign}(d,k)$ is NP-hard for any $d\ge 2$.
\end{thm}




\end{document}
